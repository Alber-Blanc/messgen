import pathlib
import subprocess
from abc import abstractmethod
from pathlib import Path
from typing import cast, List, Tuple, overload

from .model import (
    EnumType,
    BitsetType,
    ArrayType,
    BasicType,
    ExternalType,
    MapType,
    MessgenType,
    Protocol,
    StructType,
    TypeClass,
    VectorType,
    hash_message,
    hash_type,
)

CODEGEN_FILE_PREFIX = "// Code generated by messgen. DO NOT EDIT."

# - Converts snake_case to camel case
# - Ensures first letter is capitalize to enforce golang visibility
def toGoName(name: str) -> str:
    parts = name.split('_')
    return "".join([x.capitalize() for x in parts])

# Wraps messgen model
class ResolvedType:
    RESERVED_KEY_WORDS = {
        "break", "case", "chan", "const", "continue", "default", "defer", "else",
        "fallthrough", "for", "func", "go", "goto", "if", "import", "interface",
        "map", "package", "range", "return", "select", "struct", "switch", "type",
        "var",
    }

    def __init__(self, model: MessgenType, package: str):
        parsed = model.type.split("/")

        self._model = model
        self._package : list[str] = package.split('/')
        self._name = toGoName(parsed[-1])

    def name(self) -> str:
        return self._name

    def package_full(self) -> str:
        return "/".join(self._package)

    def package_name(self, mod: str | None = None):
        package_name = ""
        if self._package is not None:
            package_name = self._package[-1]
            if package_name in ResolvedType.RESERVED_KEY_WORDS:
                package_name = "_" + package_name
        elif mod is not None:
            package_name = mod.split("/")[-1]
        else:
            raise Exception(f"No package name and no module for the type {self._model.type}")

        return package_name

    def imported(self, caller_pkg = None):
        return caller_pkg != self._package

    def reference(self, caller_pkg = None):
        if self.imported(caller_pkg):
            assert(self._package is not None)
            return "%s.%s" % (self.package_name(), self._name)

        return self._name

    def is_flat(self) -> bool:
        return False

    @abstractmethod
    def alignment(self):
        raise Exception("alignment is not defined for '%s'" % self._model.type)

    @abstractmethod
    def data_size(self):
        raise Exception("data_size is not defined for '%s'" % self._model.type)

    def type_size(self):
        return self.data_size()

    def model(self):
        return self._model

    @abstractmethod
    def render(self):
        raise Exception("There is no render method for type '%s'" % self._model.type)


class FieldGroup:
    def __init__(self):
        self.size = 0
        self.pad = 0
        self.fields = []
        self.flat = True

    def description(self) -> str:
        return ",".join([name for name, _ in self.fields])

    def add_field(self, name: str, field: ResolvedType):
        self.fields.append((name, field))
        self.flat = self.flat and field.is_flat()

        if self.size == None:
            return
        elif field.data_size() != None:
            self.size += field.data_size()
        else:
            self.size = None


class ResolvedBuiltin(ResolvedType):
    def __init__(self, type_def: MessgenType, package: str):
        super().__init__(type_def, package)
        if type_def.type_class == TypeClass.bytes:
            self._name = "[]byte"
        else:
            self._name = type_def.type.lower()

    def imported(self, caller_pkg = None):
        _ = caller_pkg
        return False

    def reference(self, caller_pkg=None):
        _ = caller_pkg
        return self._name

    def alignment(self):
        if isinstance(self._model, BasicType):
            if self._model.type_class in [TypeClass.scalar]:
                return self._model.size
            elif self._model.type_class in [TypeClass.string, TypeClass.bytes]:
                # string/byte slice is a struct wth pointer and size. Pointer
                # is always maximum, so...
                return 8
        raise Exception("Unknown builtin type class for '%s'" % self._model.type)

    def is_flat(self):
        return True

    def data_size(self):
        if isinstance(self._model, BasicType):
            if self._model.type_class in [TypeClass.scalar]:
                return self._model.size
            elif self._model.type_class in [TypeClass.string, TypeClass.bytes]:
                # string/byte slice is a struct wth pointer and size. Pointer
                # is always maximum, so...
                return None
        raise Exception("Unknown builtin type class for '%s'" % self._model.type)

    def type_size(self):
        if isinstance(self._model, BasicType):
            if self._model.type_class in [TypeClass.scalar]:
                return self._model.size
            elif self._model.type_class in [TypeClass.string]:
                return 16 # len + pointer
            elif self._model.type_class in [TypeClass.bytes]:
                return 24 # len + cap + pointer
        raise Exception("Unknown builtin type class for '%s'" % self._model.type)

    def render(self):
        raise Exception("Render is not supported for ResolvedBuiltin")


class ResolvedSlice(ResolvedType):
    def __init__(self, model: ArrayType | VectorType, elem_type : ResolvedType, package: str):
        super().__init__(model, package)
        self._element = elem_type

    def imported(self, caller_pkg = None):
        return self._element.imported(caller_pkg)

    def reference(self, caller_pkg = None):
        if isinstance(self._model, ArrayType):
            return "[%d]%s" % (self._model.array_size,  self._element.reference(caller_pkg))

        return "[]%s" % self._element.reference(caller_pkg)

    def alignment(self):
        if isinstance(self._model, ArrayType):
            return self._element.alignment()
        # Dynamic vector is a slice: struc with size and pointer
        return 8

    def is_flat(self) -> bool:
        return self._element.is_flat()

    def type_size(self):
        if isinstance(self._model, ArrayType):
            return self._model.array_size * self._element.type_size()
        return 24 # cap + len + pointer

    def data_size(self):
        if isinstance(self._model, ArrayType) and self._element.data_size() != None:
            return self._element.data_size() * self._model.array_size
        # Dynamic vector has no static size
        return None

    def render(self):
        raise Exception("Render is not supported for ResolvedSlice")


class ResolvedMap(ResolvedType):
    def __init__(self, type_def: MapType, key: ResolvedType, value: ResolvedType, package : str):
        super().__init__(type_def, package)
        self._key = key 
        self._value = value 

    def imported(self, caller_pkg = None):
        return self._key.imported(caller_pkg) or self._value.imported(caller_pkg)

    def reference(self, caller_pkg = None):
        return "map[%s]%s" % (self._key.reference(caller_pkg), self._value.reference(caller_pkg))

    def is_flat(self) -> bool:
        return False

    def alignment(self):
        return 8

    def type_size(self):
        return 8 # only pointer

    def data_size(self):
        return None

    def render(self):
        raise Exception("Render is not supported for ResolvedMap")


class ResolvedEnum(ResolvedType):
    def __init__(self, type_def: EnumType, base: ResolvedType, package: str):
        super().__init__(type_def, package)
        self._base = base

    def model(self):
        return cast(EnumType, self._model)

    def alignment(self):
        return self._base.alignment()

    def data_size(self):
        return self._base.data_size()

    def is_flat(self) -> bool:
        return self._base.is_flat()

    def render(self):
        if self._base.imported(self._package):
            yield f"import \"{self._base.package_full()}\"\n"
        yield f"import \"strconv\""

        yield f"type {self.name()} {self._base.name()} \n"

        yield "const ("
        for v in self.model().values:
            yield f"\t{self.name()}_{toGoName(v.name)} {self.name()} = {v.value}"
        yield ")"

        yield f"var All{self.name()} =  [{len(self.model().values)}]{self.name()} {{"
        for v in self.model().values:
            yield f"\t{self.name()}_{toGoName(v.name)},"
        yield f"}}"

        yield f"func (v {self.name()}) String() string {{"
        yield f"\tswitch v {{"
        for v in self.model().values:
            yield f"\t// {v.comment}"
            yield f"\tcase {self.name()}_{toGoName(v.name)}:"
            yield f"\t\treturn \"{v.name}\""
        yield f"\tdefault: return strconv.FormatUint(uint64(v), 10)"
        yield f"}}"
        yield f"\t}}"

class ResolvedBitset(ResolvedType):
    def __init__(self, type_def: BitsetType, base: ResolvedType, package: str):
        super().__init__(type_def, package)
        self._base = base

    def model(self):
        return cast(BitsetType, self._model)

    def alignment(self):
        return self._base.alignment()

    def data_size(self):
        return self._base.data_size()

    def is_flat(self):
        return self._base.is_flat()

    def render(self):
        if self._base.imported(self._package):
            yield f"import \"{self._base.package_full()}\"\n"
        yield f"import \"strings\""

        yield f"type {self.name()} {self._base.name()} \n"

        yield "const ("
        for v in self.model().bits:
            yield f"\t{self.name()}_{toGoName(v.name)} {self.name()} = 1 << {v.offset}"
        yield ")"

        yield f"var All{self.name()} = [{len(self.model().bits)}]{self.name()} {{"
        for v in self.model().bits:
            yield f"\t\t{self.name()}_{toGoName(v.name)},"
        yield f"}}"
        yield f""
        yield f"func (v {self.name()}) Has(bit {self.name()}) bool {{"
        yield f"\treturn (v & bit) != 0"
        yield f"}}"
        yield f""
        yield f"func (v *{self.name()}) Set(bit {self.name()}) {{"
        yield f"\t*v = *v | bit"
        yield f"}}"
        yield f""
        yield f"func (v *{self.name()}) Clear(bit {self.name()}) {{"
        yield f"\t*v = *v & ^bit"
        yield f"}}"
        yield f""
        yield f"func (v {self.name()}) String() string {{"
        yield f"\tbuilder := strings.Builder{{}}"
        yield f"\tbuilder.WriteString(\"{{\")"
        yield f""
        yield f"\tfirst := true"
        yield f""
        yield f"\tfor _, possibleValue := range All{self.name()} {{"
        yield f"\t\tif !v.Has(possibleValue) {{"
        yield f"\t\t\tcontinue"
        yield f"\t\t}}"
        yield f""
        yield f"\t\tvar partStr string"
        yield f"\t\tswitch possibleValue {{"
        for v in self.model().bits:
            yield f"\t\t// {v.comment}"
            yield f"\t\tcase {self.name()}_{toGoName(v.name)}:"
            yield f"\t\t\tpartStr = \"{v.name}\""
        yield f"\t\t}}"
        yield f""
        yield f"\t\tif !first {{"
        yield f"\t\t\tbuilder.WriteString(\" | \")"
        yield f"\t\t}} else {{"
        yield f"\t\t\tfirst = false"
        yield f"\t\t}}"
        yield f""
        yield f"\t\tbuilder.WriteString(partStr)"
        yield f"\t}}"
        yield f""
        yield f"\tbuilder.WriteString(\"}}\")"
        yield f"\treturn builder.String()"
        yield f"}}"


class ResolvedStruct(ResolvedType):
    def __init__(self, type_def: StructType, struct_hash: int | None, package: str):
        super().__init__(type_def, package)
        self._fields: List[Tuple[str, ResolvedType]] = []
        self._imports: List[str]  = []
        self._size: None | int  = 0
        self._alignment = 1
        self._hash : int| None = struct_hash

    def add_field(self, name: str, type: ResolvedType):
        if type.imported(self._package):
            self._imports.append(type.package_full())

        self._alignment = max(self._alignment, type.alignment())

        if self._size is not None:
            if type.data_size() is not None:
                self._size += type.data_size()
            else:
                self._size = None

        self._fields.append((toGoName(name), type))

    def is_flat(self):
        for g in self.fieldGroups():
            if g.size == None or g.pad != 0:
                return False
            for _, type in g.fields:
                if not type.is_flat():
                    return False
        return True

    def alignment(self):
        return self._alignment

    def data_size(self):
        return self._size

    def type_size(self):
        totalSize = 0
        for g in self.fieldGroups():
            for f in g.fields:
                totalSize += f[1].type_size()
            totalSize += g.pad
        return totalSize

    def renderSize(self, name:str, cur: ResolvedType, step = 0):
        if cur._model.type_class == TypeClass.string or cur._model.type_class == TypeClass.bytes:
            yield f"  result += 4 + len({name})"
        elif cur._model.type_class in [TypeClass.struct, TypeClass.external]:
            yield f"  result += int({name}.SerializedSize())"
        elif isinstance(cur, ResolvedBuiltin):
            yield f"  result += {cur.type_size()}"
        elif isinstance(cur, ResolvedSlice):
            # Stack element is pair of type and data variable on this level
            elem_idx  = f"i{step}"
            elem_name = f"{name}[{elem_idx}]"
            if cur._model.type_class != TypeClass.array:
                yield f" result += 4"
            if cur._element.data_size() != None and cur._element.is_flat():
                yield f"  result += len({name})*({cur._element.type_size()})"
            else:
                yield f"for {elem_idx} := 0; {elem_idx} < len({name}); {elem_idx}++ {{"
                yield from self.renderSize(elem_name, cur._element, step+1)
                yield "}"
        elif isinstance(cur, ResolvedMap):
            yield "  result += 4"
            if cur._key._model.type_class != TypeClass.scalar and cur._value._model.type_class != TypeClass.scalar:
                yield f" for key, value := range {name} {{"
            elif cur._value._model.type_class != TypeClass.scalar:
                yield f" for _, value := range {name} {{"
            elif cur._key._model.type_class != TypeClass.scalar:
                yield f" for key, _ := range {name} {{"
            yield "// Count key "
            yield " {"
            yield from self.renderSize("key", cur._key)
            yield " }\n"
            yield "// Count value "
            yield " {"
            yield from self.renderSize("value", cur._value)
            yield " }"
            yield "  }"

    def renderSerialize(self, name: str, cur: ResolvedType, step = 0):
        if cur._model.type_class == TypeClass.string:
            yield f"  binary.LittleEndian.PutUint32(output[outputOfs:], uint32(len({name})))"
            yield f"  tmp  := unsafe.StringData({name})"
            yield f"  buf  := unsafe.Slice(tmp, len({name}))"
            yield f"  copy(output[outputOfs+4:], buf)"
            yield f"  outputOfs += 4 + len(buf)"
        elif cur._model.type_class == TypeClass.bytes:
            yield f"  binary.LittleEndian.PutUint32(output[outputOfs:], uint32(len({name})))"
            yield f"  tmp  := unsafe.SliceData({name})"
            yield f"  buf  := unsafe.Slice(tmp, len({name})*{cur.type_size()})"
            yield f"  copy(output[outputOfs+4:], buf)"
            yield f"  outputOfs += 4 + len({name})"
        elif cur._model.type_class in [TypeClass.struct, TypeClass.external]:
            yield f"  sz, err := {name}.Serialize(output[outputOfs:])"
            yield f"  if err != nil {{"
            yield f"     return uint32(outputOfs), fmt.Errorf(\"Failed to encode field '{name}'\")"
            yield f"  }}"
            yield f"  outputOfs += int(sz)"
        elif isinstance(cur, ResolvedBuiltin):
            yield f"  buf := (*[{cur.type_size()}]byte)(unsafe.Pointer(&{name}))"
            yield f"  copy(output[outputOfs:], (*buf)[0:{cur.type_size()}])"
            yield f"  outputOfs += {cur.type_size()}"
        elif isinstance(cur, ResolvedSlice):
            # Stack element is pair of type and data variable on this level
            elem_idx  = f"i{step}"
            elem_name = f"{name}[{elem_idx}]"
            if cur._model.type_class != TypeClass.array:
                yield f"  binary.LittleEndian.PutUint32(output[outputOfs:], uint32(len({name})))"
                yield f"  outputOfs += 4"

            if cur._element.data_size() != None and cur._element.is_flat():
                yield f"  uptr := unsafe.Pointer(unsafe.SliceData({name}[0:]))"
                yield f"  bytes := unsafe.Slice((*byte)(uptr), len({name})*{cur._element.type_size()})"
                yield f"  copy(output[outputOfs:], bytes)"
                yield f"  outputOfs += len(bytes)"
            else:
                yield f"for {elem_idx} := 0; {elem_idx} < len({name}); {elem_idx}++ {{"
                yield from self.renderSerialize(elem_name, cur._element, step+1)
                yield f"}}"
        elif isinstance(cur, ResolvedMap):
            elem_idx  = f"i{step}"
            yield f"  binary.LittleEndian.PutUint32(output[outputOfs:], uint32(len({name})))"
            yield f"  outputOfs += 4"
            yield f" for key, value := range {name} {{"
            yield f" // write key"
            yield f" {{"
            yield from self.renderSerialize("key", cur._key)
            yield f" }}\n"
            yield f" // write value"
            yield f" {{"
            yield from self.renderSerialize("value", cur._value)
            yield f" }}"
            yield f" }}"

    def renderDeserialize(self, name: str, cur: ResolvedType, step = 0):
        if cur._model.type_class == TypeClass.string:
            yield f"  if len(input) < inputOfs + 4 {{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  size := int(binary.LittleEndian.Uint32(input[inputOfs:]))"
            yield f"  tmp  := make([]byte, size)"
            yield f"  if len(input) < inputOfs + 4 + size {{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  copy(tmp, input[inputOfs+4:])"
            yield f"  {name} = string(tmp)"
            yield f"  inputOfs += (4+size)"
        elif cur._model.type_class == TypeClass.bytes:
            yield f"  if len(input) < inputOfs + 4 {{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  size := int(binary.LittleEndian.Uint32(input[inputOfs:]))"
            yield f"  {name} = make([]byte, size)"
            yield f"  if len(input) < inputOfs + 4 + size{{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  copy({name}, input[inputOfs+4:])"
            yield f"  inputOfs += (4+size)"
        elif cur._model.type_class in [TypeClass.struct, TypeClass.external]:
            yield f"  if len(input) < inputOfs {{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  sz, err := {name}.Deserialize(input[inputOfs:])"
            yield f"  if err != nil {{"
            yield f"     return uint32(inputOfs), fmt.Errorf(\"Failed to decode field '{name}'\")"
            yield f"  }}"
            yield f"  inputOfs += int(sz)"
        elif isinstance(cur, ResolvedBuiltin):
            yield f"  buf := (*[{cur.type_size()}]byte)(unsafe.Pointer(&{name}))"
            yield f"  if len(input) < inputOfs + {cur.type_size()} {{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  copy((*buf)[0:{cur.type_size()}], input[inputOfs:])"
            yield f"  inputOfs += {cur.type_size()}"
        elif isinstance(cur, ResolvedSlice):
            # Stack element is pair of type and data variable on this level
            elem_idx  = f"i{step}"
            elem_name = f"{name}[{elem_idx}]"
            if cur._model.type_class == TypeClass.array:
                yield f"  size := len({name})"
            else:
                yield f"  if len(input) < inputOfs + 4 {{"
                yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
                yield f"  }}"
                yield f"  size := int(binary.LittleEndian.Uint32(input[inputOfs:]))"
                yield f"  {name} = make({cur.reference(self._package)}, size)"
                yield f"  inputOfs += 4"
            if cur._element.data_size() != None and cur._element.is_flat():
                yield f"  uptr := unsafe.Pointer(unsafe.SliceData({name}[0:]))"
                yield f"  bytes := unsafe.Slice((*byte)(uptr), size*{cur._element.type_size()})"
                yield f"  if len(input) < inputOfs + len(bytes) {{"
                yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
                yield f"  }}"
                yield f"  copy(bytes, input[inputOfs:])"
                yield f"  inputOfs += len(bytes)"
            else:
                yield f"for {elem_idx} := 0; {elem_idx} < size; {elem_idx}++ {{"
                yield from self.renderDeserialize(elem_name, cur._element, step+1)
                yield f"}}"
        elif isinstance(cur, ResolvedMap):
            elem_idx  = f"i{step}"
            yield f"  if len(input) < inputOfs + 4 {{"
            yield f"     return 0, fmt.Errorf(\"Can't deserialize, input is too short\")"
            yield f"  }}"
            yield f"  size := int(binary.LittleEndian.Uint32(input[inputOfs:]))"
            yield f"  {name} = make({cur.reference(self._package)}, size)"
            yield f"  inputOfs += 4\n"
            yield f" var key {cur._key.reference(self._package)}"
            yield f" for {elem_idx} := 0; {elem_idx} < size; {elem_idx}++ {{"
            yield f" // read key"
            yield f" {{"
            yield from self.renderDeserialize("key", cur._key, step+1)
            yield f" }}\n"
            yield f" // read value"
            yield f" {{"
            yield f" var value {cur._value.reference(self._package)}"
            yield from self.renderDeserialize("value", cur._value, step+1)
            yield f" {name}[key] = value"
            yield f" }}"
            yield f" }}"

    def render(self):
        # Overall info about type:
        # Note that totalSize is struct size in memory, not size of data in the struct
        hasFlatGroups = False
        hasNonFlatGroups = False
        hasString = False
        hasBytes = False
        hasFlatSlice = False
        for g in self.fieldGroups():
            if not hasString or not hasBytes or not hasFlatSlice:
                for _, f in g.fields:
                    hasBytes = hasBytes or f._model.type_class == TypeClass.string
                    hasString = hasString or f._model.type_class == TypeClass.bytes
                    hasFlatSlice = hasFlatSlice or (
                            f._model.type_class in [TypeClass.array, TypeClass.vector] and
                            f._element.is_flat()
                    ) or (
                            f._model.type_class in [TypeClass.map] and (
                                f._key.is_flat() or 
                                f._value.is_flat()
                            )
                    )
            hasFlatGroups = hasFlatGroups or (g.size != None and g.flat)
            hasNonFlatGroups = hasNonFlatGroups or g.size == None

        # Imports
        yield f"import ("
        yield f" \"fmt\""
        yield f" \"encoding/binary\""
        if hasFlatGroups or hasString or hasBytes or hasFlatSlice:
            yield f" \"unsafe\""

        for i in self._imports:
            yield f"\"{i}\""
        yield ")\n"

        # To stop go complaints about unused imports
        yield " var _ = fmt.Print"
        yield " var _ = binary.LittleEndian"

        ##################################################################
        # Fields
        # yield self.model().comment
        yield f"type {self._name} struct {{"
        for g in self.fieldGroups():
            yield f"\t// Group begin: {g.size} bytes"
            for f in g.fields:
                # yield f.model().comment
                yield f"\t {f[0]} {f[1].reference(self._package)}"
            yield f"\t// Group end"
            if g.pad > 0:
                yield f"\t// Padding: {g.pad} bytes\n"
        yield "}"

        ##################################################################
        # Generate type hash const and method
        if self._hash is not None:
            yield f"const {self._name}_Hash = uint64({self._hash})\n"

            yield f"func (s *{self._name}) Hash() uint64 {{ return {self._name}_Hash }}\n"

        ##################################################################
        # Generate size count method
        yield f"func (s *{self._name}) SerializedSize() uint32 {{"
        yield f" result := 0"
        for g in self.fieldGroups():
            yield f"\n// Count group {g.description()}"
            if g.size != None and g.flat:
                yield f" result += {g.size}"
                continue
            for name, type in g.fields:
                yield "{"
                yield from self.renderSize("s."+name, type)
                yield "}"
        yield " return uint32(result)\n}\n"

        ##################################################################
        # Generate write methods
        yield f"func (s *{self._name}) Serialize(output []byte) (uint32, error) {{"
        if hasFlatGroups:
            yield f" selfBytes := (*[{self.type_size()}]byte)(unsafe.Pointer(s))"
        if len(self._fields) > 0:
            yield "  outputOfs, selfOfs := 0, 0"
        else:
            yield "  outputOfs := 0"
        for g in self.fieldGroups():
            yield f"\n// Write group {g.description()}"
            if g.size != None and g.flat:
                yield f" {{"
                yield f"   copy(output[outputOfs:(outputOfs+{g.size})], (*selfBytes)[selfOfs:])"
                yield f"   selfOfs  += {g.size} + {g.pad}"
                yield f"   outputOfs += {g.size}\n"
                yield f" }}"
                continue
            for name, type in g.fields:
                yield f"{{"
                yield from self.renderSerialize("s."+name, type)
                yield f"}}"
                yield f"selfOfs += {type.type_size()}"
        yield " return uint32(outputOfs), nil\n}\n"

        ##################################################################
        # Generate read methods
        yield f"func (s *{self._name}) Deserialize(input []byte) (uint32, error) {{"
        if hasFlatGroups:
            yield f" selfBytes := (*[{self.type_size()}]byte)(unsafe.Pointer(s))"
        if len(self._fields) > 0:
            yield "  inputOfs, selfOfs := 0, 0"
        else:
            yield "  inputOfs := 0"
        for g in self.fieldGroups():
            yield f"\n// Read group {g.description()}"
            if g.size != None and g.flat:
                yield f" {{"
                yield f" copy((*selfBytes)[selfOfs:(selfOfs+{g.size})], input[inputOfs:])"
                yield f" selfOfs  += {g.size} + {g.pad}"
                yield f" inputOfs += {g.size}"
                yield f" }}"
                continue
            for name, type in g.fields:
                yield "{"
                yield from self.renderDeserialize("s."+name, type)
                yield "}"
                yield f"selfOfs += {type.type_size()}"

        yield " return uint32(inputOfs), nil\n}"

    def fieldGroups(self):
        offset = 0
        max_align = 0
        group = FieldGroup()
        for name, type in self._fields:
            data_size = type.data_size()
            align = type.alignment()
            max_align = max(max_align, align)

            # Check if there is padding before this field
            if len(group.fields) > 0 and (
                    (data_size is None) or
                    (group.size is None) or
                    (data_size % align != 0) or
                    (group.size % align != 0)):
                # Start next group
                group.pad = (align - offset % align) % align
                offset += group.pad
                yield group
                group = FieldGroup()

            group.add_field(name, type)
            offset += type.type_size()

        if len(group.fields) > 0:
            group.pad = (max_align - offset % max_align) % max_align
            yield group


class ResolvedExternal(ResolvedType):
    def __init__(self, type_def: ExternalType, ext_hash: int | None, package: str):
        super().__init__(type_def, package)
        self._hash = ext_hash
        self._size = type_def.size

    def alignment(self):
        # Conservative alignment assumption; no internal layout info is available
        return 8

    def data_size(self):
        return self._size

    def type_size(self):
        return self._size if self._size is not None else 0

    def is_flat(self):
        return False

    def render(self):
        yield "import ("
        yield " \"fmt\""
        yield ")\n"

        yield " var _ = fmt.Errorf"

        yield f"type {self._name} struct {{}}\n"

        if self._hash is not None:
            yield f"const {self._name}_Hash = uint64({self._hash})\n"

        yield f"func (s *{self._name}) SerializedSize() uint32 {{"
        yield f"\tpanic(\"external type '{self._name}' is not implemented\")"
        yield "}\n"

        yield f"func (s *{self._name}) Serialize(output []byte) (uint32, error) {{"
        yield f"\treturn 0, fmt.Errorf(\"external type '{self._name}' is not implemented\")"
        yield "}\n"

        yield f"func (s *{self._name}) Deserialize(input []byte) (uint32, error) {{"
        yield f"\treturn 0, fmt.Errorf(\"external type '{self._name}' is not implemented\")"
        yield "}\n"

        if self._hash is not None:
            yield f"func (s *{self._name}) Hash() uint64 {{ return {self._name}_Hash }}\n"
        else:
            yield f"func (s *{self._name}) Hash() uint64 {{ return 0 }}\n"

def render_protocol(pkg: str, proto_name: str, proto_def: Protocol, resolved_types: dict, messgen_types: dict):
    yield CODEGEN_FILE_PREFIX + "\n"
    yield f"package {pkg}\n"
    yield "import ("
    yield "\t\"context\""
    yield "\t\"fmt\""
    yield ""
    yield "\t\"github.com/Alber-Blanc/messgen/port/golang/messgen\""

    seen = set()
    for _, msg in proto_def.messages.items():
        tp = resolved_types[msg.type]
        fp = tp.package_full()
        if fp in seen:
            continue

        yield f"\t\"{fp}\""
        seen.add(fp)
    yield ")\n"

    yield f"const Id messgen.ProtocolId = {proto_def.proto_id}"
    yield f"const Name  = \"{proto_def.name}\""

    proto_hash = 0
    message_hashes = dict()
    for id, msg in proto_def.messages.items():
        type_hash =  hash_type(messgen_types[msg.type], messgen_types)
        msg_hash = hash_message(msg) ^ type_hash if type_hash else 0
        proto_hash ^= msg_hash
        message_hashes[id] = msg_hash

    yield f"const Hash = {proto_hash}\n"

    maxid = 0
    yield "const ("
    for id, msg in proto_def.messages.items():
        yield f"\t{toGoName(msg.name)}_Id = messgen.MessageId({id})"
        maxid = max(maxid, id)
    yield "\n"
    for id, msg in proto_def.messages.items():
        yield f"\t{toGoName(msg.name)}_Hash = uint64({message_hashes[id]})"
    yield ")"
    yield ""
    for id, msg in proto_def.messages.items():
        tp = resolved_types[msg.type]
        yield f"type {toGoName(msg.name)} {tp.reference(pkg)}"
        yield f""
        yield f"func (m *{toGoName(msg.name)}) ID() messgen.PayloadId {{"
        yield f"\treturn messgen.PayloadId{{Protocol: Id, Message: {toGoName(msg.name)}_Id}}"
        yield f"}}"
        yield f""
        yield f"func (m *{toGoName(msg.name)}) Data() messgen.Serializable {{"
        yield f"\treturn (*{tp.reference(pkg)})(m)"
        yield f"}}"
        yield f""
        yield f"func (m *{toGoName(msg.name)}) Hash() uint64{{"
        yield f"\treturn {toGoName(msg.name)}_Hash"
        yield f"}}"
        yield f""

    yield f"func MessageName(mid messgen.MessageId) string {{"
    yield f"\tswitch(mid) {{"
    for id, msg in proto_def.messages.items():
        yield f"\t\t// {msg.comment}"
        yield f"\t\tcase {toGoName(msg.name)}_Id:"
        yield f"\t\t\treturn \"{toGoName(msg.name)}\""
    yield f"\t}}"
    yield ""
    yield f"\treturn fmt.Sprintf(\"Unknown message for the protocol {proto_name}: %d\", mid)"
    yield f"}}"
    yield f""
    yield f"type Dispatcher [{maxid+1}]func(ctx context.Context, body []byte) error";
    yield f""
    yield f"func NewDispatcher() *Dispatcher {{"
    yield f"return &Dispatcher{{}}"
    yield f"}}"
    yield f""

    # for each of the protocol messages generate a dispatcher setup function
    for idx, msg in enumerate(proto_def.messages.values()):
        if idx > 0:
            yield f""

        yield f"func (dispatcher *Dispatcher) SetHandler{toGoName(msg.name)}(process func(context.Context, *{toGoName(msg.name)}) error) error {{"
        yield f"\tmid := {toGoName(msg.name)}_Id"
        yield f"\tif dispatcher[int(mid)] != nil {{"
        yield f"\t\treturn fmt.Errorf(\"message id %s already has an assigned handler\", MessageName(mid))"
        yield f"\t}}\n"
        yield f"\tdispatcher[int(mid)] = func(ctx context.Context, body []byte) error {{"
        yield f"\t\tmsg := &{toGoName(msg.name)}{{}}"
        yield f"\t\tsz, err := msg.Data().Deserialize(body)"
        yield f"\t\tif err != nil {{"
        yield f"\t\t\treturn fmt.Errorf(\"failed to read message {toGoName(msg.name)}: %s\", err)"
        yield f"\t\t}} else if int(sz) != len(body) {{"
        yield f"\t\t\treturn fmt.Errorf(\"size isn't valid for the message {toGoName(msg.name)}: %d != %d\", sz, len(body))"
        yield f"\t\t}}"
        yield f""
        yield f"\t\terr = process(ctx, msg)"
        yield f"\t\tif err != nil {{"
        yield f"\t\t\treturn fmt.Errorf(\"failed to handle message {toGoName(msg.name)}: %s\",  err)"
        yield f"\t\t}}"
        yield f""
        yield f"\t\treturn nil"
        yield f"\t}}"
        yield f""
        yield f"\treturn nil"
        yield f"}}"

    yield f""
    yield f"func (dispatcher *Dispatcher) Dispatch(ctx context.Context, mid messgen.MessageId, body []byte) error {{"
    yield f"\tif len(dispatcher) <= int(mid) {{"
    yield f"\t\treturn fmt.Errorf(\"message id %d is greater than protocol's maximum message %d\", mid, {maxid})"
    yield f"\t}}"
    yield f""
    yield f"\tif int(mid) < 0 {{"
    yield f"\t\treturn fmt.Errorf(\"message id %d is less than zero\", mid)"
    yield f"\t}}\n"
    yield f""
    yield f"\thandle := dispatcher[int(mid)]"
    yield f"\tif handle == nil {{"
    yield f"\t\treturn fmt.Errorf(\"no handler found in dispatcher for message id %d\", mid)"
    yield f"\t}}\n"
    yield f"\treturn handle(ctx, body)"
    yield f"}}"


class GolangGenerator:
    PROTO_TYPE_VAR_TYPE = "uint8"

    def __init__(self, options: dict):
        self._options: dict = options
        self._types: dict[str, MessgenType] = {}
        self._resolved: dict[str, ResolvedType] = {}

    def generate_type(self, out_dir: Path, typename: str, ident=0) -> ResolvedType:
        if typename in self._resolved:
            return self._resolved[typename]
        elif typename not in self._types:
            raise Exception("Unknown type: %s" % (typename))

        # The problem is: this type could refers another types. So first check if there are
        # dependencies and render it. Use recursion for simplicity.
        # TODO(andrphi): Detect and report cycles if any
        resolved : ResolvedType | None = None
        type_def = self._types[typename]
        gomod_name = self._options["mod_name"]

        # All types except builtin has package name
        if type_def.type_class not in [TypeClass.scalar, TypeClass.bytes, TypeClass.string]:
            # type_def.type = f"{gomod_name}/{out_dir.name}/{type_def.type}"
            package_with_type = f"{gomod_name}/{out_dir.name}/{type_def.type}"
            package = package_with_type.rsplit("/", 1)[0]
        else:
            package = ""

        if type_def.type_class == TypeClass.array or type_def.type_class == TypeClass.vector:
            slice_type = cast(ArrayType | VectorType, type_def)
            tmp = self.generate_type(out_dir, slice_type.element_type, ident+2)
            resolved = ResolvedSlice(slice_type, tmp, package)
        elif type_def.type_class == TypeClass.map:
            map_type = cast(MapType, type_def)
            key_t = self.generate_type(out_dir, map_type.key_type, ident+2)
            val_t = self.generate_type(out_dir, map_type.value_type, ident+2)
            resolved = ResolvedMap(map_type, key_t, val_t, package)
        elif type_def.type_class == TypeClass.enum:
            enum_type = cast(EnumType, type_def)
            base = self.generate_type(out_dir, enum_type.base_type, ident+2)
            resolved = ResolvedEnum(enum_type, base, package)
        elif type_def.type_class == TypeClass.bitset:
            bitset_type = cast(BitsetType, type_def)
            base = self.generate_type(out_dir, bitset_type.base_type, ident+2)
            resolved = ResolvedBitset(bitset_type, base, package)
        elif type_def.type_class == TypeClass.struct:
            struct_hash: int | None = hash_type(type_def, self._types)

            struct_type = cast(StructType, type_def)
            resolved_struct = ResolvedStruct(struct_type, struct_hash, package)

            for field in struct_type.fields:
                fresolved = self.generate_type(out_dir, field.type, ident+2)
                resolved_struct.add_field(field.name, fresolved)

            resolved = resolved_struct
        elif type_def.type_class == TypeClass.external:
            ext_hash: int | None = hash_type(type_def, self._types)
            ext_type = cast(ExternalType, type_def)
            resolved = ResolvedExternal(ext_type, ext_hash, package)
        elif isinstance(type_def, BasicType):
            resolved = ResolvedBuiltin(type_def, package)
        else:
            raise Exception("Type %s is not struct/enum/bitset: %s" % (typename, type_def))

        self._resolved[typename] = resolved
        return resolved

    def generate_types(self, out_dir: Path, types: dict[str, MessgenType]) -> None:
        self._types = types

        # Outdir is package root
        # gomod_name is package prefix
        gomod_name = self._options["mod_name"]

        for type_name, _ in types.items():
            type = self.generate_type(out_dir, type_name)

            # Only struct/enum/bitset gets generated
            output = None
            if type._model.type_class in [TypeClass.struct, TypeClass.enum, TypeClass.bitset, TypeClass.external]:
                pkg = "/".join(type._package).removeprefix(f"{gomod_name}/{out_dir.name}")
                pkg = pkg.removeprefix("/")
                output = out_dir / pathlib.Path(pkg)
                output = output.joinpath(f"{type._name}_gen.go")
            else:
                continue

            output.parent.mkdir(parents=True, exist_ok=True)
            with open(output, 'w') as file:
                # Pefix
                print(f"{CODEGEN_FILE_PREFIX}\n", file=file)
                print(f"package {type.package_name(gomod_name)}\n", file=file)

                # type
                for line in type.render():
                    print(line, file=file)

                file.close()

            subprocess.call(["gofmt", "-s", "-w", output], text=True)


    def generate_protocols(self, out_dir: Path, protocols: dict[str, Protocol]) -> None:
        for proto_full_name, proto_def in protocols.items():
            proto_name = proto_full_name.split("/")[-1]

            if proto_name in ResolvedType.RESERVED_KEY_WORDS:
                proto_name = "_" + proto_name

            # pkg_name = "proto"
            file_name = out_dir / proto_full_name / "proto_gen.go"
            # out_dir = out_dir / pkg_name

            file_name.parent.mkdir(parents=True, exist_ok=True)

            with open(file_name, 'w') as file:
                for line in render_protocol(proto_name, toGoName(proto_name), proto_def, self._resolved, self._types):
                    print(line, file=file)
                file.close()

            subprocess.call(["gofmt", "-s", "-w", file_name], text=True)
